#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Automated Signal Tracker

This script automates the process of tracking signals generated by high_current.py
as trades in the tracking_manager.py system.

Usage:
- Run without arguments to track the latest signal: python auto_tracker.py
- Run with --file to specify a signal file: python auto_tracker.py --file results/live_signals/daily_signal_2025-05-20.json
- Run with --track-all to track both overall and segment signals: python auto_tracker.py --track-all
- Run with --dry-run to see what would be tracked without actually tracking: python auto_tracker.py --dry-run
"""

import os
import sys
import json
import glob
import argparse
import logging
from pathlib import Path
from datetime import datetime
from typing import List, Dict, Any, Optional, Union

# Import tracking_manager functions
from scripts.tracking_manager import add_tracked_signal, update_active_trades

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def find_latest_signal_file(signals_dir="results/live_signals") -> Optional[str]:
    """Find the latest signal JSON file in the given directory"""
    base_path = Path(os.path.dirname(os.path.abspath(__file__))) / signals_dir
    json_files = sorted(glob.glob(str(base_path / "daily_signal_*.json")))
    
    if not json_files:
        return None
    
    # Sort by file modification time (most recent first)
    return max(json_files, key=os.path.getmtime)

def load_signal_data(file_path: str) -> Dict[str, Any]:
    """Load signal data from a JSON file"""
    try:
        with open(file_path, 'r') as f:
            data = json.load(f)
        return data
    except Exception as e:
        logger.error(f"Error loading signal data from {file_path}: {e}")
        return {}

def signal_to_tracking_format(signal: Dict[str, Any]) -> Dict[str, Any]:
    """Convert a signal dictionary to the format expected by add_tracked_signal"""
    if not signal or not signal.get('signal_found', False):
        return {}
    
    # Extract the required fields
    tracking_signal = {
        'symbol': signal.get('symbol'),
        'entry_price': signal.get('entry_price'),
        'stop_loss_price': signal.get('stop_loss_price'),
        'target_price': signal.get('target_price'),
        'risk_reward_ratio': signal.get('risk_reward_ratio'),
        'atr': signal.get('atr'),
        'date': signal.get('date'),
        'notes': f"Auto-tracked from {signal.get('market_segment', 'unknown')} market. " 
                f"Setup: {signal.get('setup_type', 'unknown')}. " 
                f"Score: {signal.get('strategy_score', 'N/A')}"
    }
    
    return tracking_signal

def track_signals(signal_file: str, track_all: bool = False, dry_run: bool = False) -> List[str]:
    """
    Track signals from a signal file
    
    Args:
        signal_file: Path to the signal JSON file
        track_all: If True, track both overall and segment signals
        dry_run: If True, don't actually track signals
        
    Returns:
        List of trade IDs created
    """
    logger.info(f"Processing signal file: {signal_file}")
    
    signal_data = load_signal_data(signal_file)
    if not signal_data:
        logger.error("No signal data found or failed to load signal data")
        return []
    
    trade_ids = []
    
    # Always track the overall signal if it exists
    overall_signal = signal_data.get('overall_top_signal', {})
    if overall_signal and overall_signal.get('signal_found', False):
        tracking_signal = signal_to_tracking_format(overall_signal)
        logger.info(f"Found overall signal for {tracking_signal.get('symbol')} to track")
        
        if not dry_run:
            trade_id = add_tracked_signal(tracking_signal)
            if trade_id:
                trade_ids.append(trade_id)
                logger.info(f"Successfully tracked overall signal for {tracking_signal.get('symbol')} with ID: {trade_id}")
            else:
                logger.error(f"Failed to track overall signal for {tracking_signal.get('symbol')}")
        else:
            logger.info(f"[DRY RUN] Would track overall signal for {tracking_signal.get('symbol')}")
    else:
        logger.info("No overall signal found or signal not found flag is False")
    
    # Track segment signals if requested
    if track_all:
        segment_signals = signal_data.get('segmented_signals', {})
        for market, signal in segment_signals.items():
            if signal and signal.get('signal_found', False):
                tracking_signal = signal_to_tracking_format(signal)
                logger.info(f"Found {market} signal for {tracking_signal.get('symbol')} to track")
                
                # Skip if it's the same as the overall signal
                if overall_signal.get('symbol') == signal.get('symbol'):
                    logger.info(f"Skipping duplicate signal for {tracking_signal.get('symbol')} (already tracked as overall)")
                    continue
                
                if not dry_run:
                    trade_id = add_tracked_signal(tracking_signal)
                    if trade_id:
                        trade_ids.append(trade_id)
                        logger.info(f"Successfully tracked {market} signal for {tracking_signal.get('symbol')} with ID: {trade_id}")
                    else:
                        logger.error(f"Failed to track {market} signal for {tracking_signal.get('symbol')}")
                else:
                    logger.info(f"[DRY RUN] Would track {market} signal for {tracking_signal.get('symbol')}")
    
    # Update active trades after tracking
    if trade_ids and not dry_run:
        logger.info("Updating active trades...")
        update_active_trades()
    
    return trade_ids

def main():
    """Main function"""
    parser = argparse.ArgumentParser(description="Automated Signal Tracker")
    parser.add_argument("--file", help="Path to signal JSON file (if not specified, latest signal file will be used)")
    parser.add_argument("--track-all", action="store_true", help="Track both overall and segment signals")
    parser.add_argument("--dry-run", action="store_true", help="Don't actually track signals, just show what would be tracked")
    
    args = parser.parse_args()
    
    # Find the latest signal file if not specified
    signal_file = args.file
    if not signal_file:
        signal_file = find_latest_signal_file()
        if not signal_file:
            logger.error("No signal file found. Please run high_current.py first or specify a file with --file")
            return 1
    
    logger.info(f"Starting automated signal tracker with file: {signal_file}")
    if args.track_all:
        logger.info("Tracking all signals (overall and segments)")
    if args.dry_run:
        logger.info("DRY RUN MODE - No signals will actually be tracked")
    
    trade_ids = track_signals(signal_file, args.track_all, args.dry_run)
    
    if trade_ids:
        logger.info(f"Successfully tracked {len(trade_ids)} signals as trades")
    else:
        if args.dry_run:
            logger.info("Dry run completed. No trades were created.")
        else:
            logger.warning("No signals were tracked as trades")
    
    return 0

if __name__ == "__main__":
    sys.exit(main())
